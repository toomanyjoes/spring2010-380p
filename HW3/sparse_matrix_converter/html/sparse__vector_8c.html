<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sparse Matrix Converter: sparse_vector.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>sparse_vector.c File Reference</h1><code>#include &lt;bebop/util/config.h&gt;</code><br>
<code>#include &lt;<a class="el" href="sparse__vector_8h-source.html">bebop/smc/sparse_vector.h</a>&gt;</code><br>
<code>#include &lt;bebop/util/random_number.h&gt;</code><br>
<code>#include &lt;bebop/util/malloc.h&gt;</code><br>
<code>#include &lt;bebop/util/util.h&gt;</code><br>
<code>#include &lt;bebop/util/log.h&gt;</code><br>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#a9575a8697d7f7bff3285286f52520c4">realloc_sparse_vector</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const int newmaxlength)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#2763c0cec1139a237fbcfb2e31d82ff0">init_sparse_vector</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const int initial_length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#206a56b58491c82fd9df104524dfa53e">deinit_sparse_vector</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#f20b3e2b0d33ee12793dc7eefb77b2d4">destroy_sparse_vector</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#3b273cc1547f093ba9597a3cfbc45ec4">length_sparse_vector</a> (const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#a8063d9bee75ac01ca1ba719e68fdfc0">print_sparse_vector</a> (FILE *out, const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#2df9ab45d048f5065d5c5394552ac640">print_sparse_vector_with_line_starter</a> (FILE *out, const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const char *line_starter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#6082bebf9c4b86dc70734650a52ae8db">resize_sparse_vector</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const int newlength)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#8f93ed471de744e8f0d5e0e7175794fd">append_to_sparse_vector</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const double value, const int index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#f5d065fd9a29fcf00231f9e484e2ebac">create_sparse_vector</a> (const int initial_length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#0abfead152d4d5d6a2cee5a6d881e2b1">clone_sparse_vector</a> (const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *src)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#48397ba6891cdc1cc290d206e7ae0a2a">scatter_sparse_vector</a> (double *dest, const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *src, const int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#3f0dd55c6a1c25b1ea8165947146586e">gather_sparse_vector</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *sv, const double *dv, const int n, const double tol)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#63006e40673a41cae1a6e1445dd419db">set_sparse_vector_index</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const int i, const int index_value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#2671622454fb5280c304ce9ee8dd0678">get_sparse_vector_index</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const int i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#84db554036b103082b8bc901480d94b7">set_sparse_vector_value</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const int i, const double value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#e2a16d4ff92070942403b300918723cd">get_sparse_vector_value</a> (const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v, const int i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#26e408e6adcd8bd33b4a93fbf61f9494">ddot_svdv</a> (const double *val, const int *idx, const double *x, const int start, const int end)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#a0314601fae49c587b9dc9de2599c1fc">infinity_norm_sparse_vector</a> (const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#96efcca935cf1e1c05b3dee5c6246a88">filter_small_elements</a> (const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *x, const double tol)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#89f4639850eee4a67c1f87ec57a8cc87">swap_sparse_vector</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *a, struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#8d56d28ce1a1545aa5e8f8a3a07d17d1">sort_sparse_vector_by_index</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sparse__vector_8c.html#495d887fcf9d550288631a595f41961a">coalesce_sparse_vector_entries_with_common_indices</a> (struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *v)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9828292ca7894c012474d57746c00760"></a><!-- doxytag: member="sparse_vector.c::SPARSE_VECTOR_INIT_LENGTH" ref="9828292ca7894c012474d57746c00760" args="" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><b>SPARSE_VECTOR_INIT_LENGTH</b> = 16</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>Author:</b></dt><dd>Mark Hoemmen </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>16 Jun 2004 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>Time-stamp: &lt;2008-07-16 11:25:18 mhoemmen&gt;</dd></dl>
Copyright (c) 2008, Regents of the University of California All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of the University of California, Berkeley, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. <hr><h2>Function Documentation</h2>
<a class="anchor" name="8f93ed471de744e8f0d5e0e7175794fd"></a><!-- doxytag: member="sparse_vector.c::append_to_sparse_vector" ref="8f93ed471de744e8f0d5e0e7175794fd" args="(struct sparse_vector_t *v, const double value, const int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_to_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends the given (value,index) pair to the end of the given sparse vector.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>[IN] </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0abfead152d4d5d6a2cee5a6d881e2b1"></a><!-- doxytag: member="sparse_vector.c::clone_sparse_vector" ref="0abfead152d4d5d6a2cee5a6d881e2b1" args="(const struct sparse_vector_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a>* clone_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to a deep copy of the given sparse vector. 
</div>
</div><p>
<a class="anchor" name="495d887fcf9d550288631a595f41961a"></a><!-- doxytag: member="sparse_vector.c::coalesce_sparse_vector_entries_with_common_indices" ref="495d887fcf9d550288631a595f41961a" args="(struct sparse_vector_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coalesce_sparse_vector_entries_with_common_indices           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coalesces entries of the sparse vector which have the same index. For example, if (3.0,10) and (-5.0,10) are two (val,idx) pairs in the sparse vector, then the two entries are combined into a single entry (-2.0,10). As a side effect, sorts the sparse vector's entries by index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN/OUT] Sparse vector </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f5d065fd9a29fcf00231f9e484e2ebac"></a><!-- doxytag: member="sparse_vector.c::create_sparse_vector" ref="f5d065fd9a29fcf00231f9e484e2ebac" args="(const int initial_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a>* create_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>initial_length</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates the struct itself, then allocates initial_length entries in it. Returns a pointer to the struct.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the allocated sparse vector object </dd></dl>

</div>
</div><p>
<a class="anchor" name="26e408e6adcd8bd33b4a93fbf61f9494"></a><!-- doxytag: member="sparse_vector.c::ddot_svdv" ref="26e408e6adcd8bd33b4a93fbf61f9494" args="(const double *val, const int *idx, const double *x, const int start, const int end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ddot_svdv           </td>
          <td>(</td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the dot product of a sparse vector (represented by (val,idx) with len elements) and a dense vector x, in the index range [start, end).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>[IN] Values of sparse vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idx</em>&nbsp;</td><td>[IN] Indices of sparse vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>[IN] Dense vector</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The dot product of the sparse vector and the dense vector, unless the index range is empty, in which case it returns zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="206a56b58491c82fd9df104524dfa53e"></a><!-- doxytag: member="sparse_vector.c::deinit_sparse_vector" ref="206a56b58491c82fd9df104524dfa53e" args="(struct sparse_vector_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deinit_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees the contents of v, but not v itself.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[OUT] </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f20b3e2b0d33ee12793dc7eefb77b2d4"></a><!-- doxytag: member="sparse_vector.c::destroy_sparse_vector" ref="f20b3e2b0d33ee12793dc7eefb77b2d4" args="(struct sparse_vector_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees the contents of v, and then frees the struct v itself.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[OUT]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>Pointer invalid after calling this function. </dd></dl>

</div>
</div><p>
<a class="anchor" name="96efcca935cf1e1c05b3dee5c6246a88"></a><!-- doxytag: member="sparse_vector.c::filter_small_elements" ref="96efcca935cf1e1c05b3dee5c6246a88" args="(const struct sparse_vector_t *x, const double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a>* filter_small_elements           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a sparse vector x and a tolerance ``tol'', returns a new sparse vector which is a copy of the original x, but with all elements smaller than ``tol'' removed.<p>
UNTESTED!!! 
</div>
</div><p>
<a class="anchor" name="3f0dd55c6a1c25b1ea8165947146586e"></a><!-- doxytag: member="sparse_vector.c::gather_sparse_vector" ref="3f0dd55c6a1c25b1ea8165947146586e" args="(struct sparse_vector_t *sv, const double *dv, const int n, const double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gather_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>sv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&nbsp;</td>
          <td class="paramname"> <em>dv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gathers the given dense vector into a sparse vector, using the given tolerance to decide if an entry of the dense vector counts as zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sv</em>&nbsp;</td><td>[OUT] Sparse vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>[IN] Dense vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[IN] Length of dense vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>[IN] Tolerance for dropping nearly-zero entries of dv. Values less than or equal to this are considered zero entries and are not inserted into the sparse vector. Must be non-negative. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2671622454fb5280c304ce9ee8dd0678"></a><!-- doxytag: member="sparse_vector.c::get_sparse_vector_index" ref="2671622454fb5280c304ce9ee8dd0678" args="(struct sparse_vector_t *v, const int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_sparse_vector_index           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to the rvalue ``v-&gt;idx[i]'', with bounds checking. 
</div>
</div><p>
<a class="anchor" name="e2a16d4ff92070942403b300918723cd"></a><!-- doxytag: member="sparse_vector.c::get_sparse_vector_value" ref="e2a16d4ff92070942403b300918723cd" args="(const struct sparse_vector_t *v, const int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_sparse_vector_value           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to the r-value ``v-&gt;val[i]''. 
</div>
</div><p>
<a class="anchor" name="a0314601fae49c587b9dc9de2599c1fc"></a><!-- doxytag: member="sparse_vector.c::infinity_norm_sparse_vector" ref="a0314601fae49c587b9dc9de2599c1fc" args="(const struct sparse_vector_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double infinity_norm_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the infinity norm of the given sparse vector.<p>
UNTESTED!!! 
</div>
</div><p>
<a class="anchor" name="2763c0cec1139a237fbcfb2e31d82ff0"></a><!-- doxytag: member="sparse_vector.c::init_sparse_vector" ref="2763c0cec1139a237fbcfb2e31d82ff0" args="(struct sparse_vector_t *v, const int initial_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>initial_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates space in the given sparse vector to hold initial_length entries. Does not allocate the struct itself.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN/OUT] Pointer to the sparse vector in which space is to be allocated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>initial_length</em>&nbsp;</td><td>[IN] Initial number of entries in the sparse vector. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3b273cc1547f093ba9597a3cfbc45ec4"></a><!-- doxytag: member="sparse_vector.c::length_sparse_vector" ref="3b273cc1547f093ba9597a3cfbc45ec4" args="(const struct sparse_vector_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int length_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of entries in the sparse vector.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of entries in v </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8063d9bee75ac01ca1ba719e68fdfc0"></a><!-- doxytag: member="sparse_vector.c::print_sparse_vector" ref="a8063d9bee75ac01ca1ba719e68fdfc0" args="(FILE *out, const struct sparse_vector_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the contents of v to the given output stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN] Sparse vector </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2df9ab45d048f5065d5c5394552ac640"></a><!-- doxytag: member="sparse_vector.c::print_sparse_vector_with_line_starter" ref="2df9ab45d048f5065d5c5394552ac640" args="(FILE *out, const struct sparse_vector_t *v, const char *line_starter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_sparse_vector_with_line_starter           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>line_starter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the contents of v to the given output stream, prepending each line with line_starter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN] Sparse vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_starter</em>&nbsp;</td><td>[IN] zero-terminated string by which to prepend each line of output </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a9575a8697d7f7bff3285286f52520c4"></a><!-- doxytag: member="sparse_vector.c::realloc_sparse_vector" ref="a9575a8697d7f7bff3285286f52520c4" args="(struct sparse_vector_t *v, const int newmaxlength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>newmaxlength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Expands the reserve space in the sparse vector, without changing the number of elements (unless newmaxlength &lt; current number of elements, in which case we do change the number of elements to newmaxlength). 
</div>
</div><p>
<a class="anchor" name="6082bebf9c4b86dc70734650a52ae8db"></a><!-- doxytag: member="sparse_vector.c::resize_sparse_vector" ref="6082bebf9c4b86dc70734650a52ae8db" args="(struct sparse_vector_t *v, const int newlength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resize_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>newlength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes the given sparse vector to have a given number of entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN/OUT] Previously initialized sparse vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newlength</em>&nbsp;</td><td>[IN] New number of entries in the vector</td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>Sparse vector must be initialized first! </dd></dl>

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>(mfh 22 July 2004) This code is iffy!!! </dd></dl>

</div>
</div><p>
<a class="anchor" name="48397ba6891cdc1cc290d206e7ae0a2a"></a><!-- doxytag: member="sparse_vector.c::scatter_sparse_vector" ref="48397ba6891cdc1cc290d206e7ae0a2a" args="(double *dest, const struct sparse_vector_t *src, const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scatters the given sparse vector into a dense vector. Assumes that the entries of the sparse vector are sorted in increasing order of index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>[OUT] Dense 1-D vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>[IN] Sparse vector to scatter into dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[IN] Length of the dense vector (including structural zeros) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="63006e40673a41cae1a6e1445dd419db"></a><!-- doxytag: member="sparse_vector.c::set_sparse_vector_index" ref="63006e40673a41cae1a6e1445dd419db" args="(struct sparse_vector_t *v, const int i, const int index_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_sparse_vector_index           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>index_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to ``v-&gt;idx[i] = index_value'', with bounds checking. 
</div>
</div><p>
<a class="anchor" name="84db554036b103082b8bc901480d94b7"></a><!-- doxytag: member="sparse_vector.c::set_sparse_vector_value" ref="84db554036b103082b8bc901480d94b7" args="(struct sparse_vector_t *v, const int i, const double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_sparse_vector_value           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to ``v-&gt;val[i] = value''. 
</div>
</div><p>
<a class="anchor" name="8d56d28ce1a1545aa5e8f8a3a07d17d1"></a><!-- doxytag: member="sparse_vector.c::sort_sparse_vector_by_index" ref="8d56d28ce1a1545aa5e8f8a3a07d17d1" args="(struct sparse_vector_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sort_sparse_vector_by_index           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts the entries of v in increasing order of their indices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN/OUT] Sparse vector </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="89f4639850eee4a67c1f87ec57a8cc87"></a><!-- doxytag: member="sparse_vector.c::swap_sparse_vector" ref="89f4639850eee4a67c1f87ec57a8cc87" args="(struct sparse_vector_t *a, struct sparse_vector_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap_sparse_vector           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsparse__vector__t.html">sparse_vector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the insides of the two data structures (a shallow swap). Assumes that both a and b are valid (initialized) sparse vector objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>[IN/OUT] Sparse vector which will get the contents of b </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>[IN/OUT] Sparse vector which will get the contents of a </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 17 16:45:26 2010 for Sparse Matrix Converter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
