<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sparse Matrix Converter: bcsr_matrix.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>bcsr_matrix.h File Reference</h1><code>#include &lt;bebop/util/enumerations.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>

<p>
<a href="bcsr__matrix_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#449963d5451d32459fa902111ca94eb0">init_bcsr_matrix</a> (struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A, const int bm, const int bn, const int r, const int c, const int nnzb, void *values, int *colind, int *rowptr, const enum symmetry_type_t symmetry_type, const enum symmetric_storage_location_t symmetric_storage_location, const enum value_type_t value_type, const int col_oriented_p, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#d91ade48905c694a07ef9aae49dd6c88">unpack_bcsr_matrix</a> (struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A, int *bm, int *bn, int *r, int *c, int *nnzb, void **values, int **colind, int **rowptr, enum symmetry_type_t *symmetry_type, enum symmetric_storage_location_t *symmetric_storage_location, enum value_type_t *value_type, int *col_oriented_p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#aef4304e93f31495a1e0576c900227f3">create_bcsr_matrix_handle</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#412671c4cad4e4395f1e3c4c910f2b59">destroy_bcsr_matrix_handle</a> (struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#a6f90c02c96e99aad78c6071c2c24e30">create_bcsr_matrix</a> (const int bm, const int bn, const int r, const int c, const int nnzb, void *values, int *colind, int *rowptr, const enum symmetry_type_t symmetry_type, const enum symmetric_storage_location_t symmetric_storage_location, const enum value_type_t value_type, const int col_oriented_p, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#4996bb6b8d714b332742627df8eda099">destroy_bcsr_matrix</a> (struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#304c19f3e2b3eb2fc0ec12847762d15c">clone_bcsr_matrix</a> (struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#078a59c7e8909da5648059dec7ca7889">print_bcsr_matrix_in_matrix_market_format</a> (FILE *out, const struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#b865ddfd64943bca3dceb1100a191dbd">valid_bcsr_matrix_p</a> (const struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#2a74e8cca054ae486a85cfeb52c383d9">dump_bcsr_matrix</a> (FILE *out, const struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#4ed6169aa78b34f151db5b225f248541">identity_bcsr_matrix</a> (const int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#c9f300068dfba0c339f781c8353d3d8f">extended_identity_bcsr_matrix</a> (const int bm, const int bn, const int r, const int c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="bcsr__matrix_8h.html#62f85340b14535c5b4bf5bbbaeee8c9e">save_bcsr_matrix_in_matrix_market_format</a> (const char *const filename, struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *A)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>Author:</b></dt><dd>Mark Hoemmen </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>22 Feb 2005 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>Time-stamp: &lt;2008-07-16 10:50:11 mhoemmen&gt;</dd></dl>
BCSR (register blocked CSR) format sparse matrix data structure and member functions.<p>
Copyright (c) 2008, Regents of the University of California All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of the University of California, Berkeley, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. <hr><h2>Function Documentation</h2>
<a class="anchor" name="304c19f3e2b3eb2fc0ec12847762d15c"></a><!-- doxytag: member="bcsr_matrix.h::clone_bcsr_matrix" ref="304c19f3e2b3eb2fc0ec12847762d15c" args="(struct bcsr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a>* clone_bcsr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a deep copy of the sparse matrix A. 
</div>
</div><p>
<a class="anchor" name="a6f90c02c96e99aad78c6071c2c24e30"></a><!-- doxytag: member="bcsr_matrix.h::create_bcsr_matrix" ref="a6f90c02c96e99aad78c6071c2c24e30" args="(const int bm, const int bn, const int r, const int c, const int nnzb, void *values, int *colind, int *rowptr, const enum symmetry_type_t symmetry_type, const enum symmetric_storage_location_t symmetric_storage_location, const enum value_type_t value_type, const int col_oriented_p, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a>* create_bcsr_matrix           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nnzb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>colind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>rowptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum symmetry_type_t&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum symmetric_storage_location_t&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>col_oriented_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ownership_mode_t&nbsp;</td>
          <td class="paramname"> <em>ownership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>deallocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum copy_mode_t&nbsp;</td>
          <td class="paramname"> <em>copy_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a handle of a BCSR-format sparse matrix with the given attributes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bm</em>&nbsp;</td><td>[IN] Number of block rows </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bn</em>&nbsp;</td><td>[IN] Number of block columns </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>[IN] Number of rows in each dense subblock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>[IN] Number of columns in each dense subblock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnzb</em>&nbsp;</td><td>[IN] Number of nonzero dense subblocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>[IN] Array of values (length nnzb * r * c) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colind</em>&nbsp;</td><td>[IN] Array of column indices (length nnzb) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowptr</em>&nbsp;</td><td>[IN] Array of indices for each row (length bm) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetry_type</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetric_storage_location</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_type</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>col_oriented_p</em>&nbsp;</td><td>[IN] 0 if the nonzero blocks are row-oriented, 1 if column-oriented</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to dynamically allocated <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> object </dd></dl>

</div>
</div><p>
<a class="anchor" name="aef4304e93f31495a1e0576c900227f3"></a><!-- doxytag: member="bcsr_matrix.h::create_bcsr_matrix_handle" ref="aef4304e93f31495a1e0576c900227f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a>* create_bcsr_matrix_handle           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates a handle of a CSR-format sparse matrix. 
</div>
</div><p>
<a class="anchor" name="4996bb6b8d714b332742627df8eda099"></a><!-- doxytag: member="bcsr_matrix.h::destroy_bcsr_matrix" ref="4996bb6b8d714b332742627df8eda099" args="(struct bcsr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_bcsr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates the internal storage of A, and then the handle A itself. 
</div>
</div><p>
<a class="anchor" name="412671c4cad4e4395f1e3c4c910f2b59"></a><!-- doxytag: member="bcsr_matrix.h::destroy_bcsr_matrix_handle" ref="412671c4cad4e4395f1e3c4c910f2b59" args="(struct bcsr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_bcsr_matrix_handle           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a handle of a CSR-format sparse matrix, without touching the internal storage of the matrix. 
</div>
</div><p>
<a class="anchor" name="2a74e8cca054ae486a85cfeb52c383d9"></a><!-- doxytag: member="bcsr_matrix.h::dump_bcsr_matrix" ref="2a74e8cca054ae486a85cfeb52c383d9" args="(FILE *out, const struct bcsr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dump_bcsr_matrix           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dumps the contents of A to the given valid output stream. Mainly useful for debugging.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Pointer to BCSR format sparse matrix object </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c9f300068dfba0c339f781c8353d3d8f"></a><!-- doxytag: member="bcsr_matrix.h::extended_identity_bcsr_matrix" ref="c9f300068dfba0c339f781c8353d3d8f" args="(const int bm, const int bn, const int r, const int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a>* extended_identity_bcsr_matrix           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a generalized bm*r x bn*c "identity" matrix, with r x c blocks. Each block consists of all ones. 
</div>
</div><p>
<a class="anchor" name="4ed6169aa78b34f151db5b225f248541"></a><!-- doxytag: member="bcsr_matrix.h::identity_bcsr_matrix" ref="4ed6169aa78b34f151db5b225f248541" args="(const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a>* identity_bcsr_matrix           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the n x n identity matrix, with 1 x 1 blocks. 
</div>
</div><p>
<a class="anchor" name="449963d5451d32459fa902111ca94eb0"></a><!-- doxytag: member="bcsr_matrix.h::init_bcsr_matrix" ref="449963d5451d32459fa902111ca94eb0" args="(struct bcsr_matrix_t *A, const int bm, const int bn, const int r, const int c, const int nnzb, void *values, int *colind, int *rowptr, const enum symmetry_type_t symmetry_type, const enum symmetric_storage_location_t symmetric_storage_location, const enum value_type_t value_type, const int col_oriented_p, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_bcsr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nnzb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>colind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>rowptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum symmetry_type_t&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum symmetric_storage_location_t&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>col_oriented_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ownership_mode_t&nbsp;</td>
          <td class="paramname"> <em>ownership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>deallocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum copy_mode_t&nbsp;</td>
          <td class="paramname"> <em>copy_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills in the data structure with shallow copies of the given arguments.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[OUT] The struct to fill in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bm</em>&nbsp;</td><td>[IN] Number of block rows </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bn</em>&nbsp;</td><td>[IN] Number of block columns </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>[IN] Number of rows in each dense subblock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>[IN] Number of columns in each dense subblock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnzb</em>&nbsp;</td><td>[IN] Number of nonzero dense subblocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>[IN] Array of values (length nnzb * r * c, or NULL if this is a PATTERN matrix) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colind</em>&nbsp;</td><td>[IN] Array of column indices (length nnzb) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowptr</em>&nbsp;</td><td>[IN] Array of indices for each row (length bm) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetry_type</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetric_storage_location</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_type</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>col_oriented_p</em>&nbsp;</td><td>[IN] 0 if the nonzero blocks are row-oriented, 1 if column-oriented </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="078a59c7e8909da5648059dec7ca7889"></a><!-- doxytag: member="bcsr_matrix.h::print_bcsr_matrix_in_matrix_market_format" ref="078a59c7e8909da5648059dec7ca7889" args="(FILE *out, const struct bcsr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int print_bcsr_matrix_in_matrix_market_format           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the given BCSR-format sparse matrix A to the given output stream, in MatrixMarket format.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Zero if no error, else nonzero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="62f85340b14535c5b4bf5bbbaeee8c9e"></a><!-- doxytag: member="bcsr_matrix.h::save_bcsr_matrix_in_matrix_market_format" ref="62f85340b14535c5b4bf5bbbaeee8c9e" args="(const char *const filename, struct bcsr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_bcsr_matrix_in_matrix_market_format           </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the given BCSR-format sparse matrix A to the given filename, in MatrixMarket format. 
</div>
</div><p>
<a class="anchor" name="d91ade48905c694a07ef9aae49dd6c88"></a><!-- doxytag: member="bcsr_matrix.h::unpack_bcsr_matrix" ref="d91ade48905c694a07ef9aae49dd6c88" args="(struct bcsr_matrix_t *A, int *bm, int *bn, int *r, int *c, int *nnzb, void **values, int **colind, int **rowptr, enum symmetry_type_t *symmetry_type, enum symmetric_storage_location_t *symmetric_storage_location, enum value_type_t *value_type, int *col_oriented_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unpack_bcsr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nnzb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>colind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>rowptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetry_type_t *&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetric_storage_location_t *&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t *&nbsp;</td>
          <td class="paramname"> <em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>col_oriented_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpacks the CSR format sparse matrix into the given data structures.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] The struct from which to unpack </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bm</em>&nbsp;</td><td>[OUT] Number of block rows </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bn</em>&nbsp;</td><td>[OUT] Number of block columns </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>[OUT] Number of rows in each dense subblock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>[OUT] Number of columns in each dense subblock </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnzb</em>&nbsp;</td><td>[OUT] Number of nonzero dense subblocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>[OUT] Array of values (length nnzb * r * c, unless a PATTERN matrix) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colind</em>&nbsp;</td><td>[OUT] Array of column indices (length nnzb) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowptr</em>&nbsp;</td><td>[OUT] Array of indices for each row (length bm) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetry_type</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetric_storage_location</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_type</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>col_oriented_p</em>&nbsp;</td><td>[OUT] 0 if the nonzero blocks are row-oriented, 1 if column-oriented</td></tr>
  </table>
</dl>
FIXME: does not yet incorporate things like ownership and the deallocator! 
</div>
</div><p>
<a class="anchor" name="b865ddfd64943bca3dceb1100a191dbd"></a><!-- doxytag: member="bcsr_matrix.h::valid_bcsr_matrix_p" ref="b865ddfd64943bca3dceb1100a191dbd" args="(const struct bcsr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int valid_bcsr_matrix_p           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structbcsr__matrix__t.html">bcsr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns 1 if A is a valid BCSR format sparse matrix, else returns 0. 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 17 16:45:25 2010 for Sparse Matrix Converter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
