<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sparse Matrix Converter: spvec.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>spvec.c File Reference</h1><code>#include &lt;bebop/util/config.h&gt;</code><br>
<code>#include &lt;<a class="el" href="spvec_8h-source.html">bebop/smc/spvec.h</a>&gt;</code><br>
<code>#include &lt;bebop/util/random_number.h&gt;</code><br>
<code>#include &lt;bebop/util/malloc.h&gt;</code><br>
<code>#include &lt;bebop/util/util.h&gt;</code><br>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#6c3999d7c6d424f708ad5e5166485523">realloc_spvec</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const int newmaxlength)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="81ef584f5de168b99928f9db859b2a54"></a><!-- doxytag: member="spvec.c::init_spvec" ref="81ef584f5de168b99928f9db859b2a54" args="(struct spvec_t *v, const int initial_length, const enum value_type_t value_type)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>init_spvec</b> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const int initial_length, const enum value_type_t value_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#c57a0e94f2d4597da7f123cc11823f45">deinit_spvec</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#323a5027db7a911e683ac5c5dcec7691">destroy_spvec</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#886869abc0149fc6469bfbd8bdb64e40">length_spvec</a> (const struct <a class="el" href="structspvec__t.html">spvec_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#38bb04b8914eb1f122db8e06e99c78e3">print_spvec</a> (FILE *out, const struct <a class="el" href="structspvec__t.html">spvec_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#8d1f00ca8b8bd92be2274a69fffa0a74">print_spvec_with_line_starter</a> (FILE *out, const struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const char *line_starter)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#7146f108b6d0c05e3bdcac4503244f52">resize_spvec</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const int newlength)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#065788385a5a4101c88564525b7fde35">append_to_spvec_complex</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const double_Complex value, const int index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e48bc1b2d77fa936a47f8cd805d87042"></a><!-- doxytag: member="spvec.c::append_to_spvec_pattern" ref="e48bc1b2d77fa936a47f8cd805d87042" args="(struct spvec_t *v, const int index)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>append_to_spvec_pattern</b> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const int index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#d0db05c4955810d4a9f0c656eb3305f0">append_to_spvec</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const void *values, const int *indices, const int num_to_append)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#9ca91d9a548c8bf8e53d60d102e4bc86">create_spvec</a> (const int initial_length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#4123e050a3ea97d9a7c57c4f3d056849">clone_spvec</a> (const struct <a class="el" href="structspvec__t.html">spvec_t</a> *src)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#ed61d8ecc0369f9dbbe212743583eb69">scatter_spvec</a> (void *dest, const struct <a class="el" href="structspvec__t.html">spvec_t</a> *src, const int n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#68147dfebdaf3b7b25440031c6efb1e6">set_spvec_index</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const int i, const int index_value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#0845eae78e5dd76071f636c748c2a137">get_spvec_index</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v, const int i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#2ecf75709d4d07bc4d61f430208cd175">filter_small_elements</a> (const struct <a class="el" href="structspvec__t.html">spvec_t</a> *x, const double tol)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#096e5f6066f0f72b6a91be2946ffa663">swap_spvec</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *a, struct <a class="el" href="structspvec__t.html">spvec_t</a> *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#8650fc9cb51f8ea92a0cc5ae9bfdc5c0">sort_spvec_by_index</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#76a04f7f06fdb9d18fe6e08163cf7a56">coalesce_spvec_entries_with_common_indices</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#3216c7bd6cb65b3c989cb32be480bf9a">add_spvec</a> (struct <a class="el" href="structspvec__t.html">spvec_t</a> *z, const void *a, struct <a class="el" href="structspvec__t.html">spvec_t</a> *x, const void *b, struct <a class="el" href="structspvec__t.html">spvec_t</a> *y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="spvec_8c.html#60758560d8ad913e15f5215661d4f995">export_spvec</a> (int *ind, void *val, struct <a class="el" href="structspvec__t.html">spvec_t</a> *x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b1c67044676ebb4903bef3610e08916"></a><!-- doxytag: member="spvec.c::append_spvec_to_csr_matrix" ref="1b1c67044676ebb4903bef3610e08916" args="(int **ptr, int **ind, void **val, int *current_nnz, int *nnz_upper_bound, struct spvec_t *row, const int which_row, const int total_num_cols)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>append_spvec_to_csr_matrix</b> (int **ptr, int **ind, void **val, int *current_nnz, int *nnz_upper_bound, struct <a class="el" href="structspvec__t.html">spvec_t</a> *row, const int which_row, const int total_num_cols)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f10061e330d7d0a2d60929e8eada523"></a><!-- doxytag: member="spvec.c::SPVEC_INIT_LENGTH" ref="2f10061e330d7d0a2d60929e8eada523" args="" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><b>SPVEC_INIT_LENGTH</b> = 4</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>Author:</b></dt><dd>Mark Hoemmen </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>07 Jun 2006 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>Time-stamp: &lt;2008-07-16 11:25:26 mhoemmen&gt;</dd></dl>
Copyright (c) 2008, Regents of the University of California All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of the University of California, Berkeley, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. <hr><h2>Function Documentation</h2>
<a class="anchor" name="3216c7bd6cb65b3c989cb32be480bf9a"></a><!-- doxytag: member="spvec.c::add_spvec" ref="3216c7bd6cb65b3c989cb32be480bf9a" args="(struct spvec_t *z, const void *a, struct spvec_t *x, const void *b, struct spvec_t *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_spvec           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
z := a*x + b*y 
</div>
</div><p>
<a class="anchor" name="d0db05c4955810d4a9f0c656eb3305f0"></a><!-- doxytag: member="spvec.c::append_to_spvec" ref="d0db05c4955810d4a9f0c656eb3305f0" args="(struct spvec_t *v, const void *values, const int *indices, const int num_to_append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_to_spvec           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>num_to_append</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends the given (value,index) pairs to the end of the given sparse vector.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indices</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_to_append</em>&nbsp;</td><td>[IN] </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="065788385a5a4101c88564525b7fde35"></a><!-- doxytag: member="spvec.c::append_to_spvec_complex" ref="065788385a5a4101c88564525b7fde35" args="(struct spvec_t *v, const double_Complex value, const int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_to_spvec_complex           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double_Complex&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append a single complex value and index to the given sparse vector. 
</div>
</div><p>
<a class="anchor" name="4123e050a3ea97d9a7c57c4f3d056849"></a><!-- doxytag: member="spvec.c::clone_spvec" ref="4123e050a3ea97d9a7c57c4f3d056849" args="(const struct spvec_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspvec__t.html">spvec_t</a>* clone_spvec           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to a deep copy of the given sparse vector. 
</div>
</div><p>
<a class="anchor" name="76a04f7f06fdb9d18fe6e08163cf7a56"></a><!-- doxytag: member="spvec.c::coalesce_spvec_entries_with_common_indices" ref="76a04f7f06fdb9d18fe6e08163cf7a56" args="(struct spvec_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coalesce_spvec_entries_with_common_indices           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coalesces entries of the sparse vector which have the same index. For example, if (3.0,10) and (-5.0,10) are two (val,idx) pairs in the sparse vector, then the two entries are combined into a single entry (-2.0,10). As a side effect, sorts the sparse vector's entries by index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN/OUT] Sparse vector </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9ca91d9a548c8bf8e53d60d102e4bc86"></a><!-- doxytag: member="spvec.c::create_spvec" ref="9ca91d9a548c8bf8e53d60d102e4bc86" args="(const int initial_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspvec__t.html">spvec_t</a>* create_spvec           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>initial_length</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates the struct itself, then allocates initial_length entries in it. Returns a pointer to the struct.<p>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the allocated sparse vector object </dd></dl>

</div>
</div><p>
<a class="anchor" name="c57a0e94f2d4597da7f123cc11823f45"></a><!-- doxytag: member="spvec.c::deinit_spvec" ref="c57a0e94f2d4597da7f123cc11823f45" args="(struct spvec_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deinit_spvec           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees the contents of v, but not v itself.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[OUT] </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="323a5027db7a911e683ac5c5dcec7691"></a><!-- doxytag: member="spvec.c::destroy_spvec" ref="323a5027db7a911e683ac5c5dcec7691" args="(struct spvec_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_spvec           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees the contents of v, and then frees the struct v itself.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[OUT]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>Pointer invalid after calling this function. </dd></dl>

</div>
</div><p>
<a class="anchor" name="60758560d8ad913e15f5215661d4f995"></a><!-- doxytag: member="spvec.c::export_spvec" ref="60758560d8ad913e15f5215661d4f995" args="(int *ind, void *val, struct spvec_t *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int export_spvec           </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of the given sparse vector x into the arrays ind (for indices) and val (for values), and returns the number of (index, value) pairs written. 
</div>
</div><p>
<a class="anchor" name="2ecf75709d4d07bc4d61f430208cd175"></a><!-- doxytag: member="spvec.c::filter_small_elements" ref="2ecf75709d4d07bc4d61f430208cd175" args="(const struct spvec_t *x, const double tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspvec__t.html">spvec_t</a>* filter_small_elements           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>tol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a sparse vector x and a tolerance ``tol'', returns a new sparse vector which is a copy of the original x, but with all elements smaller than ``tol'' in absolute value removed.<p>
UNTESTED!!! 
</div>
</div><p>
<a class="anchor" name="0845eae78e5dd76071f636c748c2a137"></a><!-- doxytag: member="spvec.c::get_spvec_index" ref="0845eae78e5dd76071f636c748c2a137" args="(struct spvec_t *v, const int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int get_spvec_index           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to the rvalue ``v-&gt;idx[i]'', with bounds checking. 
</div>
</div><p>
<a class="anchor" name="886869abc0149fc6469bfbd8bdb64e40"></a><!-- doxytag: member="spvec.c::length_spvec" ref="886869abc0149fc6469bfbd8bdb64e40" args="(const struct spvec_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int length_spvec           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of entries in the sparse vector.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of entries in v </dd></dl>

</div>
</div><p>
<a class="anchor" name="38bb04b8914eb1f122db8e06e99c78e3"></a><!-- doxytag: member="spvec.c::print_spvec" ref="38bb04b8914eb1f122db8e06e99c78e3" args="(FILE *out, const struct spvec_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_spvec           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the contents of v to the given output stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN] Sparse vector </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8d1f00ca8b8bd92be2274a69fffa0a74"></a><!-- doxytag: member="spvec.c::print_spvec_with_line_starter" ref="8d1f00ca8b8bd92be2274a69fffa0a74" args="(FILE *out, const struct spvec_t *v, const char *line_starter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_spvec_with_line_starter           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>line_starter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the contents of v to the given output stream, prepending each line with line_starter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN] Sparse vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_starter</em>&nbsp;</td><td>[IN] zero-terminated string by which to prepend each line of output </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6c3999d7c6d424f708ad5e5166485523"></a><!-- doxytag: member="spvec.c::realloc_spvec" ref="6c3999d7c6d424f708ad5e5166485523" args="(struct spvec_t *v, const int newmaxlength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_spvec           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>newmaxlength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Expands the reserve space in the sparse vector, without changing the number of elements (unless newmaxlength &lt; current number of elements, in which case we do change the number of elements to newmaxlength). 
</div>
</div><p>
<a class="anchor" name="7146f108b6d0c05e3bdcac4503244f52"></a><!-- doxytag: member="spvec.c::resize_spvec" ref="7146f108b6d0c05e3bdcac4503244f52" args="(struct spvec_t *v, const int newlength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resize_spvec           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>newlength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes the given sparse vector to have a given number of entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN/OUT] Previously initialized sparse vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newlength</em>&nbsp;</td><td>[IN] New number of entries in the vector</td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>Sparse vector must be initialized first! </dd></dl>

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>(mfh 22 July 2004) This code is iffy!!! </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed61d8ecc0369f9dbbe212743583eb69"></a><!-- doxytag: member="spvec.c::scatter_spvec" ref="ed61d8ecc0369f9dbbe212743583eb69" args="(void *dest, const struct spvec_t *src, const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scatter_spvec           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scatters the given sparse vector into a dense vector, performing dest[src-&gt;idx] = dest[src-&gt;idx] + src-&gt;val. Assumes that the entries of the sparse vector are sorted in increasing order of index. We assume that the values in dest are of the same type as the values in src. If src-&gt;value_type is PATTERN, this is a noop.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>[OUT] Dense 1-D vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>[IN] Sparse vector to scatter into dest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[IN] Length of the dense vector (including structural zeros) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="68147dfebdaf3b7b25440031c6efb1e6"></a><!-- doxytag: member="spvec.c::set_spvec_index" ref="68147dfebdaf3b7b25440031c6efb1e6" args="(struct spvec_t *v, const int i, const int index_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_spvec_index           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>index_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to ``v-&gt;idx[i] = index_value'', with bounds checking. 
</div>
</div><p>
<a class="anchor" name="8650fc9cb51f8ea92a0cc5ae9bfdc5c0"></a><!-- doxytag: member="spvec.c::sort_spvec_by_index" ref="8650fc9cb51f8ea92a0cc5ae9bfdc5c0" args="(struct spvec_t *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sort_spvec_by_index           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts the entries of v in increasing order of their indices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>[IN/OUT] Sparse vector </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="096e5f6066f0f72b6a91be2946ffa663"></a><!-- doxytag: member="spvec.c::swap_spvec" ref="096e5f6066f0f72b6a91be2946ffa663" args="(struct spvec_t *a, struct spvec_t *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap_spvec           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspvec__t.html">spvec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the insides of the two data structures (a shallow swap). Assumes that both a and b are valid (initialized) sparse vector objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>[IN/OUT] Sparse vector which will get the contents of b </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>[IN/OUT] Sparse vector which will get the contents of a </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 17 16:45:26 2010 for Sparse Matrix Converter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
