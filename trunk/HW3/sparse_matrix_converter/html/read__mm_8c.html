<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sparse Matrix Converter: read_mm.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>read_mm.c File Reference</h1><code>#include &lt;bebop/util/config.h&gt;</code><br>
<code>#include &lt;<a class="el" href="coo__matrix_8h-source.html">bebop/smc/coo_matrix.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="coord__elem_8h-source.html">bebop/smc/coord_elem.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csc__matrix_8h-source.html">bebop/smc/csc_matrix.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csr__matrix_8h-source.html">bebop/smc/csr_matrix.h</a>&gt;</code><br>
<code>#include &lt;bebop/smc/mmio.h&gt;</code><br>
<code>#include &lt;<a class="el" href="read__mm_8h-source.html">bebop/smc/read_mm.h</a>&gt;</code><br>
<code>#include &lt;bebop/util/complex.h&gt;</code><br>
<code>#include &lt;bebop/util/merge_sort.h&gt;</code><br>
<code>#include &lt;bebop/util/malloc.h&gt;</code><br>
<code>#include &lt;bebop/util/util.h&gt;</code><br>
<code>#include &lt;bebop/util/log.h&gt;</code><br>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="read__mm_8c.html#01e5f114409ae265442651f3bf918af5">compare_coord_elem_by_row_real</a> (const void *a, const void *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14156797da3efcb2b38a4aa6c190bd1c"></a><!-- doxytag: member="read_mm.c::compare_coord_elem_by_row_complex" ref="14156797da3efcb2b38a4aa6c190bd1c" args="(const void *a, const void *b)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compare_coord_elem_by_row_complex</b> (const void *a, const void *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d7aa9d4e7f49e6d3b193917dd7f6b3db"></a><!-- doxytag: member="read_mm.c::compare_coord_elem_by_row_pattern" ref="d7aa9d4e7f49e6d3b193917dd7f6b3db" args="(const void *a, const void *b)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compare_coord_elem_by_row_pattern</b> (const void *a, const void *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="read__mm_8c.html#19d67de915e6b03263029588e45e8052">compare_coord_elem_by_col_real</a> (const void *a, const void *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fa446da13ba754b5551205e66d39282"></a><!-- doxytag: member="read_mm.c::compare_coord_elem_by_col_complex" ref="5fa446da13ba754b5551205e66d39282" args="(const void *a, const void *b)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compare_coord_elem_by_col_complex</b> (const void *a, const void *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5eb1a2d297a7697d1dbe1dc60e4b221c"></a><!-- doxytag: member="read_mm.c::compare_coord_elem_by_col_pattern" ref="5eb1a2d297a7697d1dbe1dc60e4b221c" args="(const void *a, const void *b)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>compare_coord_elem_by_col_pattern</b> (const void *a, const void *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36cb702778ec0853100162080d075854"></a><!-- doxytag: member="read_mm.c::sort_coord_elem_array_for_csr_conversion" ref="36cb702778ec0853100162080d075854" args="(void *coord_array, const int length, enum value_type_t value_type)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sort_coord_elem_array_for_csr_conversion</b> (void *coord_array, const int length, enum value_type_t value_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="read__mm_8c.html#8ebc7c5b09a1b7f30826fa710c0312c6">sort_coord_elem_array_for_csc_conversion</a> (void *coord_array, const int length, enum value_type_t value_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="read__mm_8c.html#5738150c82380d78bba94c5c5db60769">coo_matrix_to_coord_elem_array</a> (void **p_coord_array, int *p_length, const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="read__mm_8c.html#a1900a7d4141fb446f410137a50c5e00">coo_to_csc_matrix</a> (struct <a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *A, const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8abb7105674b9650cc4afdda6d600b3"></a><!-- doxytag: member="read_mm.c::read_matrix_market_sparse" ref="a8abb7105674b9650cc4afdda6d600b3" args="(const char *filename, struct coo_matrix_t *A)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>read_matrix_market_sparse</b> (const char *filename, struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="read__mm_8c.html#fbcec84aa16ac18d3817eeeeca5f901a">read_matrix_market_real_sparse</a> (const char *filename, struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="read__mm_8c.html#00e2b72760d19769b12d942f4e6b50bf">read_matrix_market_real_general_dense</a> (const char *filename, int *m, int *n, double **A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2cc228c1bd487b5a7b30e75adbc0ba07"></a><!-- doxytag: member="read_mm.c::coo_to_csc" ref="2cc228c1bd487b5a7b30e75adbc0ba07" args="(struct coo_matrix_t *A)" -->
<a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csc</b> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86085ad03347a235bcf893c40d8880e6"></a><!-- doxytag: member="read_mm.c::coo_to_csr" ref="86085ad03347a235bcf893c40d8880e6" args="(struct coo_matrix_t *A)" -->
<a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>coo_to_csr</b> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2a75fdfca45ce53afa38e3e5670266b"></a><!-- doxytag: member="read_mm.c::csr_to_coo" ref="a2a75fdfca45ce53afa38e3e5670266b" args="(struct csr_matrix_t *A)" -->
<a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>csr_to_coo</b> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb33d263ee32073d80e1c1462feeb41e"></a><!-- doxytag: member="read_mm.c::csc_to_coo" ref="cb33d263ee32073d80e1c1462feeb41e" args="(struct csc_matrix_t *A)" -->
<a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>csc_to_coo</b> (struct <a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *A)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>Author:</b></dt><dd>Mark Hoemmen </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>10 Jun 2004 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>Time-stamp: &lt;2009-05-16 15:42:45 mhoemmen&gt;</dd></dl>
Functions for loading and converting MatrixMarket - format sparse matrix files.<p>
Copyright (c) 2008, Regents of the University of California All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of the University of California, Berkeley, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. <hr><h2>Function Documentation</h2>
<a class="anchor" name="19d67de915e6b03263029588e45e8052"></a><!-- doxytag: member="read_mm.c::compare_coord_elem_by_col_real" ref="19d67de915e6b03263029588e45e8052" args="(const void *a, const void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_coord_elem_by_col_real           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares two coordinate-array elements by their column indices, and returns values like strcmp does. Comparison function for sorting. 
</div>
</div><p>
<a class="anchor" name="01e5f114409ae265442651f3bf918af5"></a><!-- doxytag: member="read_mm.c::compare_coord_elem_by_row_real" ref="01e5f114409ae265442651f3bf918af5" args="(const void *a, const void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_coord_elem_by_row_real           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares two coordinate-array elements by their row indices, and returns values like strcmp does. Comparison function for sorting. 
</div>
</div><p>
<a class="anchor" name="5738150c82380d78bba94c5c5db60769"></a><!-- doxytag: member="read_mm.c::coo_matrix_to_coord_elem_array" ref="5738150c82380d78bba94c5c5db60769" args="(void **p_coord_array, int *p_length, const struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coo_matrix_to_coord_elem_array           </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>p_coord_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>p_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts a coordinate (COO) format sparse matrix to coordinate array (array-of-structs) format. Allocates memory for the array of structs. Caller is responsible for freeing that memory when done.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_coord_array</em>&nbsp;</td><td>[OUT] Pointer to sparse matrix in ``coordinate array'' format </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_length</em>&nbsp;</td><td>[OUT] Pointer to number of entries in the above coordinate array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] The COO-format sparse matrix </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a1900a7d4141fb446f410137a50c5e00"></a><!-- doxytag: member="read_mm.c::coo_to_csc_matrix" ref="a1900a7d4141fb446f410137a50c5e00" args="(struct csc_matrix_t *A, const struct coo_matrix_t *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coo_to_csc_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the given coordinate (COO) format sparse matrix to CSC (aka Harwell-Boeing) format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[OUT] CSC-format sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>[IN] COO-format (struct of arrays) sparse matrix </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="00e2b72760d19769b12d942f4e6b50bf"></a><!-- doxytag: member="read_mm.c::read_matrix_market_real_general_dense" ref="00e2b72760d19769b12d942f4e6b50bf" args="(const char *filename, int *m, int *n, double **A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_matrix_market_real_general_dense           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a real (non-complex) dense matrix from a Matrix Market (v. 2.0) file, allocates space for it, and stores it in column-oriented format in A.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>[IN] Name of the MatrixMarket file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>[OUT] Number of rows in the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[OUT] Number of columns in the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[OUT] The dense matrix, in column-oriented format</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Error code (zero if no errors)</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>One can also store a vector as a dense matrix in Matrix Market format, and read it in using this function. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fbcec84aa16ac18d3817eeeeca5f901a"></a><!-- doxytag: member="read_mm.c::read_matrix_market_real_sparse" ref="fbcec84aa16ac18d3817eeeeca5f901a" args="(const char *filename, struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_matrix_market_real_sparse           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a real (non-complex) sparse matrix (general, without any sort of implicit symmetry) from a Matrix Market (v. 2.0) file, and stores it in coordinate (COO) format. For details on the Matrix Market format, see <a href="http://math.nist.gov/MatrixMarket">http://math.nist.gov/MatrixMarket </a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>[IN] Name of the MatrixMarket file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[OUT] The coordinate format matrix</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Error code (zero if no errors)</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Matrix Market files are always 1-based, i.e. the index of the first element of a matrix is (1,1), not (0,0) as in C. We adjust the offsets accordingly for C-style storage, when reading from and writing to these files. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ebc7c5b09a1b7f30826fa710c0312c6"></a><!-- doxytag: member="read_mm.c::sort_coord_elem_array_for_csc_conversion" ref="8ebc7c5b09a1b7f30826fa710c0312c6" args="(void *coord_array, const int length, enum value_type_t value_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sort_coord_elem_array_for_csc_conversion           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>coord_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Uses a stable sort algorithm to sort the structs, first by row, then by column. That will ensure that the structs are grouped in order by columns, and within a column by rows. This facilitates their later conversion into a CSC (aka Harwell-Boeing) format sparse matrix.<p>
<dl compact><dt><b>Note:</b></dt><dd>Quicksort is NOT stable!!! but merge sort (with &lt;= comparison) is.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>coord_array</em>&nbsp;</td><td>Sparse matrix in ``coordinate array'' format </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>Number of entries in the coordinate array (number of stored (nonzero) entries in the matrix) </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 17 16:45:26 2010 for Sparse Matrix Converter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
