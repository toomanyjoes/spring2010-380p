<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sparse Matrix Converter: interface.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>interface.h File Reference</h1>
<p>
<a href="interface_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_8h.html#a2af5f23862bea32c5e7dbfd277f71ce">sp_load</a> (const char *path, const char *fmt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_8h.html#3a010d1d2638fd9ec1479d9b70a61ca9">sp_save</a> (struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *A, const char *path, const char *fmt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_8h.html#da80cad7cf0bf62a7913865e0864b4c1">sp_format</a> (struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_8h.html#ffb943968a2b39d12fcf8b824aec7ad1">sp_convert</a> (struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *A, const char *type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_8h.html#02dd137959b94a709e4f433de504d9ac">sp_mult</a> (struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *B, struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_8h.html#ac86c7e45014e95d98612deabca7ae5e">sp_triprod</a> (struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *RT, struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *A, struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *P)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_8h.html#b56e5c10fa4e88cc3a9dee9e9126b51c">sp_print</a> (struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_8h.html#02eca7c6138aa4e7971be38e1f774867">sp_destroy</a> (struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *A)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>Author:</b></dt><dd>Mark Hoemmen </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>09 Jun 2006 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>Time-stamp: &lt;2008-07-16 10:55:32 mhoemmen&gt;</dd></dl>
Basic sparse matrix functionality. Intended for use by a Foreign Function Interface, SWIG, or some other such method for calling C functions from other languages. This is really only intended for basic "load a file, convert it and save it" functionality. For more extensive functionality, the files <a class="el" href="sparse__matrix_8h.html">sparse_matrix.h</a> and <a class="el" href="sparse__matrix__ops_8h.html">sparse_matrix_ops.h</a> are recommended.<p>
Copyright (c) 2008, Regents of the University of California All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of the University of California, Berkeley, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. <hr><h2>Function Documentation</h2>
<a class="anchor" name="ffb943968a2b39d12fcf8b824aec7ad1"></a><!-- doxytag: member="interface.h::sp_convert" ref="ffb943968a2b39d12fcf8b824aec7ad1" args="(struct sparse_matrix_t *A, const char *type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_convert           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the internal storage format of the given sparse matrix to the given type.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN/OUT] Pointer to a sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>[IN] The target type, e.g. "COO", "CSR", "JAD"</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if conversion was successful, else nonzero.</dd></dl>
Not all conversions are supported. 
</div>
</div><p>
<a class="anchor" name="02eca7c6138aa4e7971be38e1f774867"></a><!-- doxytag: member="interface.h::sp_destroy" ref="02eca7c6138aa4e7971be38e1f774867" args="(struct sparse_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sp_destroy           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates the given sparse matrix handle and its internal storage of the sparse matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN/OUT] Pointer to a sparse matrix </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="da80cad7cf0bf62a7913865e0864b4c1"></a><!-- doxytag: member="interface.h::sp_format" ref="da80cad7cf0bf62a7913865e0864b4c1" args="(struct sparse_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sp_format           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the internal storage format of the given sparse matrix to stdout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Pointer to a sparse matrix </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a2af5f23862bea32c5e7dbfd277f71ce"></a><!-- doxytag: member="interface.h::sp_load" ref="a2af5f23862bea32c5e7dbfd277f71ce" args="(const char *path, const char *fmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a>* sp_load           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a sparse matrix of the given type from the given file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>[IN] Path to the sparse matrix file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>[IN] File format. Currently accepted values are "MATRIX_MARKET", "HARWELL_BOEING" and "MATLAB". </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to the sparse matrix loaded from the file, or NULL if the load failed (e.g. incorrect path or file format). </dd></dl>

</div>
</div><p>
<a class="anchor" name="02dd137959b94a709e4f433de504d9ac"></a><!-- doxytag: member="interface.h::sp_mult" ref="02dd137959b94a709e4f433de504d9ac" args="(struct sparse_matrix_t *B, struct sparse_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a>* sp_mult           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sparse matrix which is the product B * A.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>[IN] Pointer to a sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Pointer to a sparse matrix</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The product matrix B * A</dd></dl>
Experimental and not supported for all matrix types! 
</div>
</div><p>
<a class="anchor" name="b56e5c10fa4e88cc3a9dee9e9126b51c"></a><!-- doxytag: member="interface.h::sp_print" ref="b56e5c10fa4e88cc3a9dee9e9126b51c" args="(struct sparse_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sp_print           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints A to stdout in Matrix Market format. 
</div>
</div><p>
<a class="anchor" name="3a010d1d2638fd9ec1479d9b70a61ca9"></a><!-- doxytag: member="interface.h::sp_save" ref="3a010d1d2638fd9ec1479d9b70a61ca9" args="(struct sparse_matrix_t *A, const char *path, const char *fmt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sp_save           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the given sparse matrix to the given path in the given format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Pointer to a sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>[IN] Path to the desired output file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fmt</em>&nbsp;</td><td>[IN] File format. Currently accepted values are "MATRIX_MARKET", "HARWELL_BOEING" and "MATLAB". </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if successful, else nonzero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac86c7e45014e95d98612deabca7ae5e"></a><!-- doxytag: member="interface.h::sp_triprod" ref="ac86c7e45014e95d98612deabca7ae5e" args="(struct sparse_matrix_t *RT, struct sparse_matrix_t *A, struct sparse_matrix_t *P)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a>* sp_triprod           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>RT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structsparse__matrix__t.html">sparse_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>P</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sparse matrix R*A*P, in which R is given as R^T.<p>
Experimental and not supported for all matrix types! 
</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 17 16:45:26 2010 for Sparse Matrix Converter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
