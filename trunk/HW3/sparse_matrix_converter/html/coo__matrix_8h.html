<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sparse Matrix Converter: coo_matrix.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>coo_matrix.h File Reference</h1><code>#include &lt;bebop/util/enumerations.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>

<p>
<a href="coo__matrix_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#f2aebb3e97885ed7c7e9d2b195c22b6c">init_coo_matrix</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A, int m, int n, int nnz, int *II, int *JJ, void *val, enum index_base_t index_base, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96e6534bda1e330f01bb6abd29cd7427"></a><!-- doxytag: member="coo_matrix.h::create_coo_matrix" ref="96e6534bda1e330f01bb6abd29cd7427" args="(int m, int n, int nnz, int *II, int *JJ, void *val, enum index_base_t index_base, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)" -->
<a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_coo_matrix</b> (int m, int n, int nnz, int *II, int *JJ, void *val, enum index_base_t index_base, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#3b03e00fefe57c8f2d0782ad50c329b6">reserve_coo_matrix</a> (const int m, const int n, const int nnz, enum index_base_t index_base, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#cb5f646a6dc52b30ff054ecf269b6dca">valid_coo_matrix_p</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#88e33e88368fe9d28ea56f079c24d4c9">destroy_coo_matrix</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#5166660a6bea0dee9999f6cc3b6923df">copy_coo_matrix</a> (const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#b0364b17eb5fe8f2228de654a3bee28a">coo_matrix_equal_p</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A, struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#1d2b1bd081cf1b8357569bd1e77711a0">csc_to_coo_matrix</a> (const struct <a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *A, int index_base)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#bfc58ff744f1738e51eee92e51ee161c">coo_c_to_fortran</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#b5be72b4c64ca7f307dcad9fc60caf03">coo_fortran_to_c</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#a8f0668ada66a0bdde814856d8ee4f55">alloc_coo_matrix</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A, const int m, const int n, const int nnz, enum index_base_t index_base, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#bdf5bf86cb2a4a9fecf36599c87c36ff">dealloc_coo_matrix</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#06b172e427e4e66734209b4fd841a7be">coo_matrix_in_fortran_format_p</a> (const int m, const int n, const int nnz, const int II[], const int JJ[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#e94349a09d5ea2e7a99e3d9f81d67d1b">print_coo_matrix_in_matrix_market_format</a> (FILE *out, const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#14535d1b1900488ac9cf87cdc5477a9f">save_coo_matrix_in_harwell_boeing_format</a> (const char *const filename, const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#4277a23f23c91e4d238b106c2e6ffd22">save_coo_matrix_in_matrix_market_format</a> (const char *const filename, const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#804e0a2a5fa9afb4a879d341bf295cbd">print_coo_matrix_in_matlab_format</a> (FILE *out, struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#4be013ee4d379af512e98f6d8e626864">save_coo_matrix_in_matlab_format</a> (const char *const filename, struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#5143b2ced37460f0745046c5350ccc7e">load_coo_matrix_in_matlab_format</a> (const char *const filename)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#9c8ee071f8669f642edd6bf0c741228a">coo_matrix_expand_symmetric_storage</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="coo__matrix_8h.html#55b480aabe1605fcbd7010e51517d38b">coo_matrix_expand_symmetric_storage_copy</a> (struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *A)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>Author:</b></dt><dd>Mark Hoemmen </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>26 May 2005 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>Time-stamp: &lt;2008-07-16 10:50:16 mhoemmen&gt;</dd></dl>
Wrapper for a coordinate (ijv) format sparse matrix.<p>
Copyright (c) 2008, Regents of the University of California All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of the University of California, Berkeley, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. <hr><h2>Function Documentation</h2>
<a class="anchor" name="a8f0668ada66a0bdde814856d8ee4f55"></a><!-- doxytag: member="coo_matrix.h::alloc_coo_matrix" ref="a8f0668ada66a0bdde814856d8ee4f55" args="(struct coo_matrix_t *A, const int m, const int n, const int nnz, enum index_base_t index_base, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void alloc_coo_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum index_base_t&nbsp;</td>
          <td class="paramname"> <em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetry_type_t&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetric_storage_location_t&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocates storage in the given struct for the matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Coordinate format sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>[IN] Number of rows in the matrix A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[IN] Number of columns in the matrix A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnz</em>&nbsp;</td><td>[IN] Number of nonzero entries in the matrix A</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>This automatically sets ownership to LIBRARY_DEALLOCATES and the deallocator to the default. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bfc58ff744f1738e51eee92e51ee161c"></a><!-- doxytag: member="coo_matrix.h::coo_c_to_fortran" ref="bfc58ff744f1738e51eee92e51ee161c" args="(struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coo_c_to_fortran           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the indices in A from C indexing (zero-based) to Fortran indexing (one-based).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN/OUT] Sparse matrix in coordinate (COO) format </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b5be72b4c64ca7f307dcad9fc60caf03"></a><!-- doxytag: member="coo_matrix.h::coo_fortran_to_c" ref="b5be72b4c64ca7f307dcad9fc60caf03" args="(struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void coo_fortran_to_c           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the indices in A from Fortran indexing (one-based) to C indexing (zero-based).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN/OUT] Sparse matrix in coordinate (COO) format </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b0364b17eb5fe8f2228de654a3bee28a"></a><!-- doxytag: member="coo_matrix.h::coo_matrix_equal_p" ref="b0364b17eb5fe8f2228de654a3bee28a" args="(struct coo_matrix_t *A, struct coo_matrix_t *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coo_matrix_equal_p           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns nonzero if the given COO format sparse matrices are identical (i.e. deep copies of each other), else returns zero. As a side effect, sorts the entries of A and B.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] COO format sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>[IN] COO format sparse matrix </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9c8ee071f8669f642edd6bf0c741228a"></a><!-- doxytag: member="coo_matrix.h::coo_matrix_expand_symmetric_storage" ref="9c8ee071f8669f642edd6bf0c741228a" args="(struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coo_matrix_expand_symmetric_storage           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a sparse matrix in COO format that uses a symmetric form of storage, and expands it "in place" into an unsymmetric storage format (so that all the nonzeros are stored explicitly).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN/OUT] Sparse matrix in COO format</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if error, else zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="55b480aabe1605fcbd7010e51517d38b"></a><!-- doxytag: member="coo_matrix.h::coo_matrix_expand_symmetric_storage_copy" ref="55b480aabe1605fcbd7010e51517d38b" args="(struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a>* coo_matrix_expand_symmetric_storage_copy           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a sparse matrix in COO format that uses a symmetric form of storage, and expands it into an unsymmetric storage format (so that all the nonzeros are stored explicitly).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN/OUT] Sparse matrix in COO format</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL if error, else the expanded sparse matrix in COO format </dd></dl>

</div>
</div><p>
<a class="anchor" name="06b172e427e4e66734209b4fd841a7be"></a><!-- doxytag: member="coo_matrix.h::coo_matrix_in_fortran_format_p" ref="06b172e427e4e66734209b4fd841a7be" args="(const int m, const int n, const int nnz, const int II[], const int JJ[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coo_matrix_in_fortran_format_p           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>II</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>JJ</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether the indices in the given COO-format sparse matrix are within their valid ranges, for Fortran-style (1-based) indices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>[IN] Number of rows in the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[IN] Number of columns in the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnz</em>&nbsp;</td><td>[IN] Number of structural nonzeros (stored elements) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>II</em>&nbsp;</td><td>[IN] Array of row indices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>JJ</em>&nbsp;</td><td>[IN] Array of column indices</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if indices in range, 0 if an index is out of range. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5166660a6bea0dee9999f6cc3b6923df"></a><!-- doxytag: member="coo_matrix.h::copy_coo_matrix" ref="5166660a6bea0dee9999f6cc3b6923df" args="(const struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a>* copy_coo_matrix           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a deep copy of the given COO format sparse matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Valid pointer to a <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1d2b1bd081cf1b8357569bd1e77711a0"></a><!-- doxytag: member="coo_matrix.h::csc_to_coo_matrix" ref="1d2b1bd081cf1b8357569bd1e77711a0" args="(const struct csc_matrix_t *A, int index_base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a>* csc_to_coo_matrix           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index_base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a sparse matrix of CSC (compressed sparse column, aka Harwell-Boeing) format, creates a copy of the matrix in COO (coordinate) format and returns a pointer to the freshly allocated copy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Sparse matrix in compressed sparse column format </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index_base</em>&nbsp;</td><td>[IN] ZERO or ONE; the index base (C-style or Fortran-style) of the output COO format sparse matrix.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Freshly allocated copy of the input matrix, in COO format </dd></dl>

</div>
</div><p>
<a class="anchor" name="bdf5bf86cb2a4a9fecf36599c87c36ff"></a><!-- doxytag: member="coo_matrix.h::dealloc_coo_matrix" ref="bdf5bf86cb2a4a9fecf36599c87c36ff" args="(struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dealloc_coo_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates the dynamic memory used to store the matrix. 
</div>
</div><p>
<a class="anchor" name="88e33e88368fe9d28ea56f079c24d4c9"></a><!-- doxytag: member="coo_matrix.h::destroy_coo_matrix" ref="88e33e88368fe9d28ea56f079c24d4c9" args="(struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_coo_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates the struct A and the storage it contains.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN/OUT] Valid pointer to a dynamically allocated <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f2aebb3e97885ed7c7e9d2b195c22b6c"></a><!-- doxytag: member="coo_matrix.h::init_coo_matrix" ref="f2aebb3e97885ed7c7e9d2b195c22b6c" args="(struct coo_matrix_t *A, int m, int n, int nnz, int *II, int *JJ, void *val, enum index_base_t index_base, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_coo_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>II</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>JJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum index_base_t&nbsp;</td>
          <td class="paramname"> <em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetry_type_t&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetric_storage_location_t&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ownership_mode_t&nbsp;</td>
          <td class="paramname"> <em>ownership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>deallocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum copy_mode_t&nbsp;</td>
          <td class="paramname"> <em>copy_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the given struct A to be the given COO format sparse matrix.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[OUT] Valid pointer to uninitialized struct. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>[IN] Number of rows </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[IN] Number of columns </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnz</em>&nbsp;</td><td>[IN] Number of nonzero entries </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>II</em>&nbsp;</td><td>[IN] Array of row indices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>JJ</em>&nbsp;</td><td>[IN] Array of column indices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>[IN] Array of nonzero values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index_base</em>&nbsp;</td><td>[IN] Base of the indices (ZERO or ONE). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetry_type</em>&nbsp;</td><td>[IN] Symmetry type of the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetric_storage_location</em>&nbsp;</td><td>[IN] If the matrix has symmetry, where the nonzeros are stored. If the matrix is to be stored in unsymmetric format, the value of this enum is irrelevant. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_type</em>&nbsp;</td><td>[IN] </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5143b2ced37460f0745046c5350ccc7e"></a><!-- doxytag: member="coo_matrix.h::load_coo_matrix_in_matlab_format" ref="5143b2ced37460f0745046c5350ccc7e" args="(const char *const filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a>* load_coo_matrix_in_matlab_format           </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads a COO-format sparse matrix from the given file, in Matlab ASCII format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>[IN] Name of file from which to load the sparse matrix</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL if error, else pointer to COO-format sparse matrix </dd></dl>

</div>
</div><p>
<a class="anchor" name="804e0a2a5fa9afb4a879d341bf295cbd"></a><!-- doxytag: member="coo_matrix.h::print_coo_matrix_in_matlab_format" ref="804e0a2a5fa9afb4a879d341bf295cbd" args="(FILE *out, struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int print_coo_matrix_in_matlab_format           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the given COO matrix to the given file stream, in Matlab format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid file stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Sparse matrix in COO format</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if error, else zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e94349a09d5ea2e7a99e3d9f81d67d1b"></a><!-- doxytag: member="coo_matrix.h::print_coo_matrix_in_matrix_market_format" ref="e94349a09d5ea2e7a99e3d9f81d67d1b" args="(FILE *out, const struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int print_coo_matrix_in_matrix_market_format           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the given COO matrix to the given file stream, in MatrixMarket format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid file stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Sparse matrix in COO format</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if error, else zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b03e00fefe57c8f2d0782ad50c329b6"></a><!-- doxytag: member="coo_matrix.h::reserve_coo_matrix" ref="3b03e00fefe57c8f2d0782ad50c329b6" args="(const int m, const int n, const int nnz, enum index_base_t index_base, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a>* reserve_coo_matrix           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum index_base_t&nbsp;</td>
          <td class="paramname"> <em>index_base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetry_type_t&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetric_storage_location_t&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates and returns a <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> object, uninitialized, with nnz space reserved.<p>
<dl compact><dt><b>Note:</b></dt><dd>automatically sets ownership to LIBRARY_DEALLOCATES and the deallocator to free(). If ownership was previously LIBRARY_DEALLOCATES but the deallocator not the default, then the non-default deallocator is used to deallocate the original arrays, but the new arrays are allocated with the default deallocator (malloc). </dd></dl>

</div>
</div><p>
<a class="anchor" name="14535d1b1900488ac9cf87cdc5477a9f"></a><!-- doxytag: member="coo_matrix.h::save_coo_matrix_in_harwell_boeing_format" ref="14535d1b1900488ac9cf87cdc5477a9f" args="(const char *const filename, const struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_coo_matrix_in_harwell_boeing_format           </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save the given COO matrix to the given file, in Harwell-Boeing format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>[IN] Filename to which to save the given sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Sparse matrix in COO format to save</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if error, else zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4be013ee4d379af512e98f6d8e626864"></a><!-- doxytag: member="coo_matrix.h::save_coo_matrix_in_matlab_format" ref="4be013ee4d379af512e98f6d8e626864" args="(const char *const filename, struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_coo_matrix_in_matlab_format           </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save the given COO matrix to the given file, in Matlab ASCII format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>[IN] Filename to which to save the given sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Sparse matrix in COO format to save</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if error, else zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4277a23f23c91e4d238b106c2e6ffd22"></a><!-- doxytag: member="coo_matrix.h::save_coo_matrix_in_matrix_market_format" ref="4277a23f23c91e4d238b106c2e6ffd22" args="(const char *const filename, const struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_coo_matrix_in_matrix_market_format           </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save the given COO matrix to the given file, in MatrixMarket format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>[IN] Filename to which to save the given sparse matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Sparse matrix in COO format to save</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if error, else zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb5f646a6dc52b30ff054ecf269b6dca"></a><!-- doxytag: member="coo_matrix.h::valid_coo_matrix_p" ref="cb5f646a6dc52b30ff054ecf269b6dca" args="(struct coo_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int valid_coo_matrix_p           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcoo__matrix__t.html">coo_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true (nonzero) if A is a valid COO format sparse matrix, else returns zero.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] Coordinate (COO) format sparse matrix </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 17 16:45:25 2010 for Sparse Matrix Converter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
