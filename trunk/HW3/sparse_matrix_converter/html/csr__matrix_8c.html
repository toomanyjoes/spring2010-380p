<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sparse Matrix Converter: csr_matrix.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>csr_matrix.c File Reference</h1><code>#include &lt;bebop/util/config.h&gt;</code><br>
<code>#include &lt;<a class="el" href="csr__matrix_8h-source.html">bebop/smc/csr_matrix.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csr__expand__to__dense_8h-source.html">bebop/smc/csr_expand_to_dense.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csr__matmatmult_8h-source.html">bebop/smc/csr_matmatmult.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csr__spmv_8h-source.html">bebop/smc/csr_spmv.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csr__triple__product_8h-source.html">bebop/smc/csr_triple_product.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csr__trisolve_8h-source.html">bebop/smc/csr_trisolve.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csr__weighted__jacobi_8h-source.html">bebop/smc/csr_weighted_jacobi.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="coo__matrix_8h-source.html">bebop/smc/coo_matrix.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="csc__matrix_8h-source.html">bebop/smc/csc_matrix.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="iohb_8h-source.html">bebop/smc/iohb.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="read__mm_8h-source.html">bebop/smc/read_mm.h</a>&gt;</code><br>
<code>#include &lt;<a class="el" href="sparse__vector_8h-source.html">bebop/smc/sparse_vector.h</a>&gt;</code><br>
<code>#include &lt;bebop/util/complex.h&gt;</code><br>
<code>#include &lt;bebop/util/malloc.h&gt;</code><br>
<code>#include &lt;bebop/util/util.h&gt;</code><br>
<code>#include &lt;bebop/util/log.h&gt;</code><br>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structindex__real__value__pair__t.html">index_real_value_pair_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>index_complex_value_pair_t</b></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>INERZ</b>(thing)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>INEARZ</b>(array, idx)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#f1bf56eda6ecac49e31083e53ae83dfa">pack_csr_matrix</a> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, const int m, const int n, const int nnz, void *values, int *colidx, int *rowptr, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#b00463024dce24c34c1e9b1a25183221">init_csr_matrix</a> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, const int m, const int n, const int nnz, void *values, int *colidx, int *rowptr, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#3763b10a1845f94f3761edff27535472">dealloc_csr_matrix</a> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#935cc2772c7b0a6538b98d6557bc8255">clone_csr_matrix</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *src)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#2a80cae7fec9b3935fbd80d2ee2c736e">copy_csr_matrix</a> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *dest, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *src)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#c5cb6ce0586737b7fc535da66b468848">unpack_csr_matrix</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, int *m, int *n, int *nnz, void **values, int **colidx, int **rowptr, enum symmetry_type_t *symmetry_type, enum symmetric_storage_location_t *symmetric_storage_location, enum value_type_t *value_type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#93ce817de5f871e9bfd01305cac3c4a1">create_csr_matrix</a> (const int m, const int n, const int nnz, void *values, int *colidx, int *rowptr, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#e3136e98ff1d98608f202319fe349e62">destroy_csr_matrix</a> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#c61b79c18b6485fcc59c01557b9e52c3">csr_to_csc</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#1318a95d3832f048e015b0c2e0549224">csc_to_csr</a> (struct <a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#4eac330c2d2d0510d748838181685e20">save_csr_matrix_in_harwell_boeing_format</a> (const char *const filename, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#7d8a3e641ccf46936316f1edbff4bbe9">print_csr_matrix_in_matrix_market_format</a> (FILE *out, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#21d764b015e4a4eac23e09378710099d">save_csr_matrix_in_matrix_market_format</a> (const char *const filename, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#b26af4ef606ae7f4464a0459e78fb065">csr_matrix_expand_symmetric_storage</a> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#9be75e664e980e8646ff7c427f889ed7">print_csr_matrix_in_matlab_format</a> (FILE *out, struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#f3fd7d424ec63cc0ed65b4ece6b9501b">save_csr_matrix_in_matlab_format</a> (const char *const filename, struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#40cd236b1361c157be6b79c66d9855b1">valid_csr_matrix_p</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#63694d1d0fddc7b9245328fd6fd0fee6">csr_matrix_matmatmult</a> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *B, struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#5520038b3e3b7aef73bd71253a73a7be">csr_matrix_triple_product</a> (struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *RT, struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *P)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#3fa8612fdd659d3fe84d5babd9c98e26">csr_matrix_expand_to_dense</a> (void *B, const int col_oriented, const int ldb, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#79447f41e90dcedcb9d42e421bf8613a">csr_matrix_weighted_jacobi</a> (void *y, const void *weight, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, const void *x, const void *r)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#ff8d5339dee755909f450c75cdaa9b87">csr_matrix_num_rows</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#634b1b4721dfc84d27281dc2634e5492">csr_matrix_num_cols</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#0c9e59b8718e6f67b44ed9155569c2ef">csr_spmv</a> (void *y, const void *beta, const void *alpha, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, const void *x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#c9dd697fc8253d86d64558531ebaf279">csr_upper_trisolve</a> (void *x, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#74cc738c6ef14ec32202f1e6eb40673f">csr_lower_trisolve</a> (void *x, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#c042e4ec8b4c0c9a237925a57d557a58">csr_spmv_transpose</a> (void *y, const void *beta, const void *alpha, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, const void *x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#f7b531fc58a7428afa074bd2e22b0dc1">display_csr_matrix_in_matrix_market_format</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#ea868e5dc507f9c15c572e3fefd0895d">csr_matrix_restrict</a> (void *rc, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *RT, const void *r)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#7b5cf931085e4c1610f97caba4e42168">csr_matrix_transpose</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#dafc5b54481ae899bb90e51bfeb195b4">csr_matrix_equal_p</a> (const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *B)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="csr__matrix_8c.html#3fe91e70bf000b512d2dbbe63160de09">csr_gauss_seidel</a> (void *x, const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *A, const void *b, const char *direction)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b>Author:</b></dt><dd>Mark Hoemmen </dd></dl>
<dl compact><dt><b>Since:</b></dt><dd>31 May 2005 </dd></dl>
<dl compact><dt><b>Date:</b></dt><dd>Time-stamp: &lt;2008-07-16 11:15:52 mhoemmen&gt;</dd></dl>
Copyright (c) 2008, Regents of the University of California All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:<p>
* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.<p>
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.<p>
* Neither the name of the University of California, Berkeley, nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. <hr><h2>Define Documentation</h2>
<a class="anchor" name="68a326c5557374c0327d7fd37ac9b7dd"></a><!-- doxytag: member="csr_matrix.c::INEARZ" ref="68a326c5557374c0327d7fd37ac9b7dd" args="(array, idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INEARZ          </td>
          <td>(</td>
          <td class="paramtype">array,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">idx&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
    <span class="keywordflow">if</span> (Acopy.array[<a class="code" href="structspvec__t.html#fe9cba0753537a967d35a162124514c3">idx</a>] != Bcopy.array[<a class="code" href="structspvec__t.html#fe9cba0753537a967d35a162124514c3">idx</a>]) { \
      bebop_log (2, <span class="stringliteral">"### csr_matrix_equal_p: array %s element %d not equal ###\n"</span>, #array , <a class="code" href="structspvec__t.html#fe9cba0753537a967d35a162124514c3">idx</a> ); \
      <span class="keywordflow">goto</span> cleanup; \
    } \
  } <span class="keywordflow">while</span>(0)
</pre></div>
</div>
</div><p>
<a class="anchor" name="3ba64726a5718a097961e0a88ada11db"></a><!-- doxytag: member="csr_matrix.c::INERZ" ref="3ba64726a5718a097961e0a88ada11db" args="(thing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INERZ          </td>
          <td>(</td>
          <td class="paramtype">thing&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> { \
    <span class="keywordflow">if</span> (Acopy.thing != Bcopy.thing) { \
      bebop_log (2, <span class="stringliteral">"### csr_matrix_equal_p: %s not equal ###\n"</span>, #thing ); \
      <span class="keywordflow">goto</span> cleanup; \
    } \
  } <span class="keywordflow">while</span>(0)
</pre></div>
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="935cc2772c7b0a6538b98d6557bc8255"></a><!-- doxytag: member="csr_matrix.c::clone_csr_matrix" ref="935cc2772c7b0a6538b98d6557bc8255" args="(const struct csr_matrix_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a>* clone_csr_matrix           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a deep copy of src. 
</div>
</div><p>
<a class="anchor" name="2a80cae7fec9b3935fbd80d2ee2c736e"></a><!-- doxytag: member="csr_matrix.c::copy_csr_matrix" ref="2a80cae7fec9b3935fbd80d2ee2c736e" args="(struct csr_matrix_t *dest, const struct csr_matrix_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_csr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deep-copies src into dest.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>[OUT] </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="93ce817de5f871e9bfd01305cac3c4a1"></a><!-- doxytag: member="csr_matrix.c::create_csr_matrix" ref="93ce817de5f871e9bfd01305cac3c4a1" args="(const int m, const int n, const int nnz, void *values, int *colidx, int *rowptr, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a>* create_csr_matrix           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>colidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>rowptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetry_type_t&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetric_storage_location_t&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ownership_mode_t&nbsp;</td>
          <td class="paramname"> <em>ownership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>deallocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum copy_mode_t&nbsp;</td>
          <td class="paramname"> <em>copy_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dynamically allocates a new <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> object, and fills it in with the given arguments.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>[IN] Number of rows in the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[IN] Number of columns in the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnz</em>&nbsp;</td><td>[IN] Number of nonzero entries in the matrix</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>[IN] Array (length nnz) of nonzero values; shallow copy if copy_mode == NO_COPY, deep copy if copy_mode == COPY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colidx</em>&nbsp;</td><td>[IN] Array (length nnz) of column indices for each nonzero value; shallow copy if copy_mode == NO_COPY, deep copy if copy_mode == COPY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowptr</em>&nbsp;</td><td>[IN] Array (length m+1) of row pointers; shallow copy if copy_mode == NO_COPY, deep copy if copy_mode == COPY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetry_type</em>&nbsp;</td><td>[IN] Indicates whether the matrix uses some form of symmetric storage </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetric_storage_location</em>&nbsp;</td><td>[IN] If some form of symmetric storage is used, indicates where the nonzeros are (upper or lower triangle). Otherwise, this parameter is ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_type</em>&nbsp;</td><td>[IN] REAL, COMPLEX or PATTERN </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownership</em>&nbsp;</td><td>[IN] Who deallocates values, colidx and rowptr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deallocator</em>&nbsp;</td><td>[IN] Function for deallocating those arrays </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_mode</em>&nbsp;</td><td>[IN] Whether to copy the input arrays values, colidx and rowptr</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pointer to freshly allocated <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> object </dd></dl>

</div>
</div><p>
<a class="anchor" name="1318a95d3832f048e015b0c2e0549224"></a><!-- doxytag: member="csr_matrix.c::csc_to_csr" ref="1318a95d3832f048e015b0c2e0549224" args="(struct csc_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a>* csc_to_csr           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a copy of the given CSC-format sparse matrix in CSR format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL if error, else a valid malloc'd CSR-format sparse matrix </dd></dl>

</div>
</div><p>
<a class="anchor" name="3fe91e70bf000b512d2dbbe63160de09"></a><!-- doxytag: member="csr_matrix.c::csr_gauss_seidel" ref="3fe91e70bf000b512d2dbbe63160de09" args="(void *x, const struct csr_matrix_t *A, const void *b, const char *direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csr_gauss_seidel           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does Gauss-Seidel:<p>
If direction is "forward", does $x := (D - L)^{-1} (Ux + b)$, in which $A = D - L - U$. If direction is "backward", does $x := (D - U)^{-1} (Lx + b)$. If direction is "symmetric", does first forward and then backward.<p>
Experimental; currently only implemented for unsymmetric matrices. 
</div>
</div><p>
<a class="anchor" name="74cc738c6ef14ec32202f1e6eb40673f"></a><!-- doxytag: member="csr_matrix.c::csr_lower_trisolve" ref="74cc738c6ef14ec32202f1e6eb40673f" args="(void *x, const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csr_lower_trisolve           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
x := L \ x, in which L is the lower triangle of A. 
</div>
</div><p>
<a class="anchor" name="dafc5b54481ae899bb90e51bfeb195b4"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_equal_p" ref="dafc5b54481ae899bb90e51bfeb195b4" args="(const struct csr_matrix_t *A, const struct csr_matrix_t *B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csr_matrix_equal_p           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns nonzero iff A is a deep copy of B, modulo the ordering of the column indices in each row, the deallocator, ownership type, etc.<p>
Allocates a lot of temporary storage (at least twice that of the input) in order to avoid modifying A or B. 
</div>
</div><p>
<a class="anchor" name="b26af4ef606ae7f4464a0459e78fb065"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_expand_symmetric_storage" ref="b26af4ef606ae7f4464a0459e78fb065" args="(struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csr_matrix_expand_symmetric_storage           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the sparse matrix A is stored in a symmetric space-saving format, expands out A so that all the nonzeros ((i,j) and (j,i)) are explicitly stored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN/OUT] Sparse matrix in CSR format</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if error, else zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3fa8612fdd659d3fe84d5babd9c98e26"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_expand_to_dense" ref="3fa8612fdd659d3fe84d5babd9c98e26" args="(void *B, const int col_oriented, const int ldb, const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csr_matrix_expand_to_dense           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>col_oriented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills in B, a dense matrix, with the contents of the sparse matrix A. We assume that B is already allocated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>B</em>&nbsp;</td><td>[OUT] Gets the contents of A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>col_oriented</em>&nbsp;</td><td>[IN] Indicates whether B is a column-oriented or row-oriented matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] CSR format sparse matrix</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Zero if no errors, else nonzero </dd></dl>

</div>
</div><p>
<a class="anchor" name="63694d1d0fddc7b9245328fd6fd0fee6"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_matmatmult" ref="63694d1d0fddc7b9245328fd6fd0fee6" args="(struct csr_matrix_t *B, struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a>* csr_matrix_matmatmult           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns C := B * A, a sparse matrix in CSR format. Returns NULL on error, e.g. if B and A don't have the same value type, or if the data format isn't supported (e.g. symmetric storage may not be implemented yet). 
</div>
</div><p>
<a class="anchor" name="634b1b4721dfc84d27281dc2634e5492"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_num_cols" ref="634b1b4721dfc84d27281dc2634e5492" args="(const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csr_matrix_num_cols           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of columns in A 
</div>
</div><p>
<a class="anchor" name="ff8d5339dee755909f450c75cdaa9b87"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_num_rows" ref="ff8d5339dee755909f450c75cdaa9b87" args="(const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int csr_matrix_num_rows           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of rows in A 
</div>
</div><p>
<a class="anchor" name="ea868e5dc507f9c15c572e3fefd0895d"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_restrict" ref="ea868e5dc507f9c15c572e3fefd0895d" args="(void *rc, const struct csr_matrix_t *RT, const void *r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csr_matrix_restrict           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>RT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restriction operator rc := R * r, in which R is the transpose of RT, with elements in each row scaled by the sum of the elements in that row. 
</div>
</div><p>
<a class="anchor" name="7b5cf931085e4c1610f97caba4e42168"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_transpose" ref="7b5cf931085e4c1610f97caba4e42168" args="(const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a>* csr_matrix_transpose           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the transpose of A. 
</div>
</div><p>
<a class="anchor" name="5520038b3e3b7aef73bd71253a73a7be"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_triple_product" ref="5520038b3e3b7aef73bd71253a73a7be" args="(struct csr_matrix_t *RT, struct csr_matrix_t *A, struct csr_matrix_t *P)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a>* csr_matrix_triple_product           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>RT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>P</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs the "triple product" kernel used for algebraic multigrid: Returns R * A * P, in which R, A and P are CSR format m x n n x n n x m sparse matrices. R is provided as R^T ("RT"), so that e.g. P can be used as R^T. (RT == P is allowed.) Does not exploit possible symmetry in A. 
</div>
</div><p>
<a class="anchor" name="79447f41e90dcedcb9d42e421bf8613a"></a><!-- doxytag: member="csr_matrix.c::csr_matrix_weighted_jacobi" ref="79447f41e90dcedcb9d42e421bf8613a" args="(void *y, const void *weight, const struct csr_matrix_t *A, const void *x, const void *r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csr_matrix_weighted_jacobi           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Does weighted Jacobi smoothing: y := x + weight * inv(diag(A)) * r.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>[OUT] Array of elements of the same type as the elements in A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>[IN] Pointer to a value of the same type as the elements in A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] CSR format sparse matrix: must be square </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>[IN] Array of elements of the same type as the elements in A </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>[IN] Array of elements of the same type as the elements in A </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c9e59b8718e6f67b44ed9155569c2ef"></a><!-- doxytag: member="csr_matrix.c::csr_spmv" ref="0c9e59b8718e6f67b44ed9155569c2ef" args="(void *y, const void *beta, const void *alpha, const struct csr_matrix_t *A, const void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csr_spmv           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y := beta * y + alpha * A * x, in which A is a CSR format sparse matrix. All vectors and scalars should have the same data type as the elements in the sparse matrix A. 
</div>
</div><p>
<a class="anchor" name="c042e4ec8b4c0c9a237925a57d557a58"></a><!-- doxytag: member="csr_matrix.c::csr_spmv_transpose" ref="c042e4ec8b4c0c9a237925a57d557a58" args="(void *y, const void *beta, const void *alpha, const struct csr_matrix_t *A, const void *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csr_spmv_transpose           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
y := beta * y + alpha * A^T * x, in which A is a CSR format sparse matrix. All vectors and scalars should have the same data type as the elements in the sparse matrix A. 
</div>
</div><p>
<a class="anchor" name="c61b79c18b6485fcc59c01557b9e52c3"></a><!-- doxytag: member="csr_matrix.c::csr_to_csc" ref="c61b79c18b6485fcc59c01557b9e52c3" args="(const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structcsc__matrix__t.html">csc_matrix_t</a>* csr_to_csc           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a copy of the given CSR-format sparse matrix in CSC format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN]</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NULL if error, else a valid malloc'd CSC-format sparse matrix </dd></dl>

</div>
</div><p>
<a class="anchor" name="c9dd697fc8253d86d64558531ebaf279"></a><!-- doxytag: member="csr_matrix.c::csr_upper_trisolve" ref="c9dd697fc8253d86d64558531ebaf279" args="(void *x, const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void csr_upper_trisolve           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
x := U \ x, in which U is the upper triangle of A. 
</div>
</div><p>
<a class="anchor" name="3763b10a1845f94f3761edff27535472"></a><!-- doxytag: member="csr_matrix.c::dealloc_csr_matrix" ref="3763b10a1845f94f3761edff27535472" args="(struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dealloc_csr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates the data structures used by A. 
</div>
</div><p>
<a class="anchor" name="e3136e98ff1d98608f202319fe349e62"></a><!-- doxytag: member="csr_matrix.c::destroy_csr_matrix" ref="e3136e98ff1d98608f202319fe349e62" args="(struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void destroy_csr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deallocates the data structures used by A, and the <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> data structure itself. 
</div>
</div><p>
<a class="anchor" name="f7b531fc58a7428afa074bd2e22b0dc1"></a><!-- doxytag: member="csr_matrix.c::display_csr_matrix_in_matrix_market_format" ref="f7b531fc58a7428afa074bd2e22b0dc1" args="(const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int display_csr_matrix_in_matrix_market_format           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equivalent to print_csr_matrix_in_matrix_market_format (stdout, A) 
</div>
</div><p>
<a class="anchor" name="b00463024dce24c34c1e9b1a25183221"></a><!-- doxytag: member="csr_matrix.c::init_csr_matrix" ref="b00463024dce24c34c1e9b1a25183221" args="(struct csr_matrix_t *A, const int m, const int n, const int nnz, void *values, int *colidx, int *rowptr, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_csr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>colidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>rowptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetry_type_t&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetric_storage_location_t&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ownership_mode_t&nbsp;</td>
          <td class="paramname"> <em>ownership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>deallocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum copy_mode_t&nbsp;</td>
          <td class="paramname"> <em>copy_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synonym for <a class="el" href="csr__matrix_8h.html#f1bf56eda6ecac49e31083e53ae83dfa">pack_csr_matrix()</a> 
</div>
</div><p>
<a class="anchor" name="f1bf56eda6ecac49e31083e53ae83dfa"></a><!-- doxytag: member="csr_matrix.c::pack_csr_matrix" ref="f1bf56eda6ecac49e31083e53ae83dfa" args="(struct csr_matrix_t *A, const int m, const int n, const int nnz, void *values, int *colidx, int *rowptr, enum symmetry_type_t symmetry_type, enum symmetric_storage_location_t symmetric_storage_location, enum value_type_t value_type, enum ownership_mode_t ownership, void(*deallocator)(void *), enum copy_mode_t copy_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pack_csr_matrix           </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>colidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>rowptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetry_type_t&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetric_storage_location_t&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t&nbsp;</td>
          <td class="paramname"> <em>value_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ownership_mode_t&nbsp;</td>
          <td class="paramname"> <em>ownership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>deallocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum copy_mode_t&nbsp;</td>
          <td class="paramname"> <em>copy_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills in the CSR format sparse matrix data structure with copies of the given arguments.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[OUT] The struct to fill in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>[IN] Number of rows in the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[IN] Number of columns in the matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnz</em>&nbsp;</td><td>[IN] Number of nonzero entries in the matrix</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>[IN] Array (length nnz) of nonzero values; shallow copy if copy_mode == NO_COPY, deep copy if copy_mode == COPY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colidx</em>&nbsp;</td><td>[IN] Array (length nnz) of column indices for each nonzero value; shallow copy if copy_mode == NO_COPY, deep copy if copy_mode == COPY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowptr</em>&nbsp;</td><td>[IN] Array (length m+1) of row pointers; shallow copy if copy_mode == NO_COPY, deep copy if copy_mode == COPY </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetry_type</em>&nbsp;</td><td>[IN] Indicates whether the matrix uses some form of symmetric storage </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetric_storage_location</em>&nbsp;</td><td>[IN] If some form of symmetric storage is used, indicates where the nonzeros are (upper or lower triangle). Otherwise, this parameter is ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_type</em>&nbsp;</td><td>[IN] REAL, COMPLEX or PATTERN </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ownership</em>&nbsp;</td><td>[IN] Who deallocates values, colidx and rowptr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deallocator</em>&nbsp;</td><td>[IN] Function for deallocating those arrays </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy_mode</em>&nbsp;</td><td>[IN] Whether to copy the input arrays values, colidx and rowptr </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9be75e664e980e8646ff7c427f889ed7"></a><!-- doxytag: member="csr_matrix.c::print_csr_matrix_in_matlab_format" ref="9be75e664e980e8646ff7c427f889ed7" args="(FILE *out, struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int print_csr_matrix_in_matlab_format           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the given CSR-format matrix to the given output stream in Matlab format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid (open) output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] CSR-format sparse matrix</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Zero if no error, else nonzero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7d8a3e641ccf46936316f1edbff4bbe9"></a><!-- doxytag: member="csr_matrix.c::print_csr_matrix_in_matrix_market_format" ref="7d8a3e641ccf46936316f1edbff4bbe9" args="(FILE *out, const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int print_csr_matrix_in_matrix_market_format           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the given CSR-format matrix to the given output stream in MatrixMarket format.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>[OUT] Valid (open) output stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] CSR-format sparse matrix</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Zero if no error, else nonzero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4eac330c2d2d0510d748838181685e20"></a><!-- doxytag: member="csr_matrix.c::save_csr_matrix_in_harwell_boeing_format" ref="4eac330c2d2d0510d748838181685e20" args="(const char *const filename, const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_csr_matrix_in_harwell_boeing_format           </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the given matrix in Harwell-Boeing format to the given file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>[IN] The file to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] The matrix (in Harwell-Boeing format)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nonzero if something went wrong, else zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3fd7d424ec63cc0ed65b4ece6b9501b"></a><!-- doxytag: member="csr_matrix.c::save_csr_matrix_in_matlab_format" ref="f3fd7d424ec63cc0ed65b4ece6b9501b" args="(const char *const filename, struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_csr_matrix_in_matlab_format           </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the given CSR-format sparse matrix A to the given filename, in Matlab format. 
</div>
</div><p>
<a class="anchor" name="21d764b015e4a4eac23e09378710099d"></a><!-- doxytag: member="csr_matrix.c::save_csr_matrix_in_matrix_market_format" ref="21d764b015e4a4eac23e09378710099d" args="(const char *const filename, const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_csr_matrix_in_matrix_market_format           </td>
          <td>(</td>
          <td class="paramtype">const char *const &nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the given CSR-format sparse matrix A to the given filename, in MatrixMarket format. 
</div>
</div><p>
<a class="anchor" name="c5cb6ce0586737b7fc535da66b468848"></a><!-- doxytag: member="csr_matrix.c::unpack_csr_matrix" ref="c5cb6ce0586737b7fc535da66b468848" args="(const struct csr_matrix_t *A, int *m, int *n, int *nnz, void **values, int **colidx, int **rowptr, enum symmetry_type_t *symmetry_type, enum symmetric_storage_location_t *symmetric_storage_location, enum value_type_t *value_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unpack_csr_matrix           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>nnz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>colidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>rowptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetry_type_t *&nbsp;</td>
          <td class="paramname"> <em>symmetry_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum symmetric_storage_location_t *&nbsp;</td>
          <td class="paramname"> <em>symmetric_storage_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum value_type_t *&nbsp;</td>
          <td class="paramname"> <em>value_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpacks the CSC format sparse matrix into the given data structures.<p>
FIXME: needs to include ownership and deallocator!<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>A</em>&nbsp;</td><td>[IN] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nnz</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>colidx</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rowptr</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetry_type</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symmetric_storage_location</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_type</em>&nbsp;</td><td>[OUT] </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40cd236b1361c157be6b79c66d9855b1"></a><!-- doxytag: member="csr_matrix.c::valid_csr_matrix_p" ref="40cd236b1361c157be6b79c66d9855b1" args="(const struct csr_matrix_t *A)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int valid_csr_matrix_p           </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structcsr__matrix__t.html">csr_matrix_t</a> *&nbsp;</td>
          <td class="paramname"> <em>A</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns nonzero if the given CSR format sparse matrix has valid indices, else returns zero. 
<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>Should be cur &gt;= nnz, right???? </dd></dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 17 16:45:26 2010 for Sparse Matrix Converter by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
